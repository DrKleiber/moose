/****************************************************************/
/*               DO NOT MODIFY THIS HEADER                      */
/* MOOSE - Multiphysics Object Oriented Simulation Environment  */
/*                                                              */
/*           (c) 2010 Battelle Energy Alliance, LLC             */
/*                   ALL RIGHTS RESERVED                        */
/*                                                              */
/*          Prepared by Battelle Energy Alliance, LLC           */
/*            Under Contract No. DE-AC07-05ID14517              */
/*            With the U. S. Department of Energy               */
/*                                                              */
/*            See COPYRIGHT for full restrictions               */
/****************************************************************/

#include "RaySystem.h"

// Local Includes
#include "RayProblem.h"
#include "RayKernel.h"
#include "RayBC.h"
#include "RayMaterial.h"

// MOOSE Includes
#include "MooseMesh.h"
#include "Factory.h"
#include "MooseTypes.h"

// libMesh Includes
#include "libmesh/quadrature_gauss.h"
#include "libmesh/node_range.h"
#include "libmesh/numeric_vector.h"

// System Includes
#include <numeric>

RaySystem::RaySystem(RayProblemBase & subproblem, const std::string & name, unsigned long int num_groups)
  : SystemBase(subproblem, name, Moose::VAR_AUXILIARY),
    ConsoleStreamInterface(subproblem.getMooseApp()),
    _ray_problem(subproblem),
    _sys(_ray_problem.es().add_system<TransientExplicitSystem>(name)),
    _rs_threaded_data(libMesh::n_threads()),
    _num_groups(num_groups),
    _current_group_solution(dynamic_cast<PetscVector<Number> &>(solution()))
{
  for (unsigned long int tid = 0; tid < libMesh::n_threads(); tid++)
    _rs_threaded_data[tid]._group_solution = dynamic_cast<PetscVector<Number> *>(
        &_sys.add_vector("thread_group_solution_" + std::to_string(tid), false, PARALLEL));

  FEType var_type(CONSTANT, MONOMIAL);

  for (unsigned long int g = 0; g < _num_groups; g++)
    addVariable("group_" + std::to_string(g), var_type, 1.0);

  _console << "\nCreated RaySystem!!!\n" << std::endl;

  std::cout << "Size of Node: " << sizeof(Node) << std::endl;
  std::cout << "Size of Elem: " << sizeof(Elem) << std::endl;
}

RaySystem::~RaySystem() {}

void
RaySystem::init()
{
}

void
RaySystem::initialSetup()
{
  if (_ray_problem._solve_ray)
  {
    // Check for domain coverage for RayKernels
    if (_ray_problem.rayKernelCoverageCheck())
    {
      std::set<SubdomainID> subdomains;
      std::set<std::string> variables;
      _ray_kernels.subdomainsCovered(subdomains, variables);

      std::set<SubdomainID> missing;
      std::set_difference(_mesh.meshSubdomains().begin(),
                          _mesh.meshSubdomains().end(),
                          subdomains.begin(),
                          subdomains.end(),
                          std::inserter(missing, missing.begin()));

      if (!missing.empty())
      {
        std::ostringstream error;
        error << "Subdomains { ";
        std::copy(missing.begin(), missing.end(), std::ostream_iterator<SubdomainID>(error, " "));
        error << "} do not have RayKernels defined!";

        mooseError(error.str());
      }
    }

    // Check for domain coverage for RayMaterials
    if (_ray_problem.rayMaterialCoverageCheck())
    {
      std::set<SubdomainID> subdomains;
      std::set<std::string> variables;
      _ray_materials.subdomainsCovered(subdomains, variables);

      std::set<SubdomainID> missing;
      std::set_difference(_mesh.meshSubdomains().begin(),
                          _mesh.meshSubdomains().end(),
                          subdomains.begin(),
                          subdomains.end(),
                          std::inserter(missing, missing.begin()));

      if (!missing.empty())
      {
        std::ostringstream error;
        error << "Subdomains { ";
        std::copy(missing.begin(), missing.end(), std::ostream_iterator<SubdomainID>(error, " "));
        error << "} do not have RayMaterials defined!";

        mooseError(error.str());
      }
    }
  }

  for (THREAD_ID tid = 0; tid < libMesh::n_threads(); tid++)
  {
    _ray_kernels.initialSetup(tid);
    _ray_materials.initialSetup(tid);
  }

  for (THREAD_ID tid = 0; tid < libMesh::n_threads(); tid++)
    updateActive(tid);
}

void
RaySystem::timestepSetup()
{
  for (THREAD_ID tid = 0; tid < libMesh::n_threads(); tid++)
  {
    _ray_kernels.timestepSetup(tid);
    _ray_materials.timestepSetup(tid);
  }
}

void
RaySystem::subdomainSetup()
{
  for (THREAD_ID tid = 0; tid < libMesh::n_threads(); tid++)
  {
    _ray_kernels.subdomainSetup(tid);
    _ray_materials.subdomainSetup(tid);
  }
}

void
RaySystem::jacobianSetup()
{
  for (THREAD_ID tid = 0; tid < libMesh::n_threads(); tid++)
  {
    _ray_kernels.jacobianSetup(tid);
    _ray_materials.jacobianSetup(tid);
  }
}

void
RaySystem::residualSetup()
{
  for (THREAD_ID tid = 0; tid < libMesh::n_threads(); tid++)
  {
    _ray_kernels.residualSetup(tid);
    _ray_materials.residualSetup(tid);
  }
}

void
RaySystem::updateActive(THREAD_ID tid)
{
  _ray_kernels.updateActive(tid);
  _ray_bcs.updateActive(tid);
  _ray_materials.updateActive(tid);
}

void
RaySystem::addRayKernel(const std::string & mk_name,
                        const std::string & name,
                        InputParameters parameters)
{
  _console << "Adding RayKernel!" << std::endl;

  parameters.set<FEProblem *>("_fe_problem") = &_ray_problem;
  parameters.set<FEProblemBase *>("_fe_problem_base") = &_ray_problem;
  parameters.set<SubProblem *>("_subproblem") = &_ray_problem;

  for (THREAD_ID tid = 0; tid < libMesh::n_threads(); tid++)
  {
    MooseSharedPointer<RayKernel> mk = _factory.create<RayKernel>(mk_name, name, parameters, tid);
    _ray_kernels.addObject(mk, tid);
  }
}

void
RaySystem::addRayBC(const std::string & mbc_name,
                    const std::string & name,
                    InputParameters parameters)
{
  _console << "Adding RayBCl!" << std::endl;

  parameters.set<FEProblem *>("_fe_problem") = &_ray_problem;
  parameters.set<FEProblemBase *>("_fe_problem_base") = &_ray_problem;
  parameters.set<SubProblem *>("_subproblem") = &_ray_problem;

  for (THREAD_ID tid = 0; tid < libMesh::n_threads(); tid++)
  {
    MooseSharedPointer<RayBC> mbc = _factory.create<RayBC>(mbc_name, name, parameters, tid);
    _ray_bcs.addObject(mbc, tid);
  }
}

void
RaySystem::addRayMaterial(const std::string & mk_name,
                          const std::string & name,
                          InputParameters parameters)
{
  _console << "Adding RayMaterial!" << std::endl;

  parameters.set<FEProblem *>("_fe_problem") = &_ray_problem;
  parameters.set<FEProblemBase *>("_fe_problem_base") = &_ray_problem;
  parameters.set<SubProblem *>("_subproblem") = &_ray_problem;

  for (THREAD_ID tid = 0; tid < libMesh::n_threads(); tid++)
  {
    MooseSharedPointer<RayMaterial> mk =
        _factory.create<RayMaterial>(mk_name, name, parameters, tid);

    _ray_materials.addObject(mk, tid);

    MooseSharedPointer<RayMaterial> mk_neighbor =
        _factory.create<RayMaterial>(mk_name, name + "_neighbor", parameters, tid);

    _ray_materials_neighbor.addObject(mk_neighbor, tid);
  }
}

void
RaySystem::subdomainSetup(SubdomainID current_subdomain, THREAD_ID tid)
{
  if (_ray_materials.getBlockObjects(current_subdomain, tid).size() == 0)
    std::cerr << current_subdomain << std::endl;

  auto & block_mats = _ray_materials.getBlockObjects(current_subdomain, tid);

  if (block_mats.empty() || block_mats[0] == nullptr)
    mooseError("No RayMaterial defined on ", current_subdomain);

  _rs_threaded_data[tid]._current_ray_material = block_mats[0];
}

void
RaySystem::augmentSparsity(SparsityPattern::Graph & /*sparsity*/,
                           std::vector<dof_id_type> & /*n_nz*/,
                           std::vector<dof_id_type> & /*n_oz*/)
{
}

void
RaySystem::solve()
{
  Moose::perf_log.push("RaySystem::solve()", "Execution");

  for (unsigned long int tid = 0; tid < libMesh::n_threads(); tid++)
  {
    _ray_kernels.updateActive(tid);
    _ray_materials.updateActive(tid);
  }

  sweep();

  postSweep();

  Moose::perf_log.pop("RaySystem::solve()", "Execution");
}

void
RaySystem::reinitElem(const Elem * elem, THREAD_ID tid, bool only_sigma_t)
{
  auto & threaded_data = _rs_threaded_data[tid];

  dof_id_type dof_number = elem->dof_number(number(), 0, 0);

  threaded_data._current_offset =
      threaded_data._group_solution->map_global_to_local_index(dof_number);

  if (only_sigma_t)
    threaded_data._current_ray_material->reinitSigmaT(elem);
  else
    threaded_data._current_ray_material->reinit(elem);

  threaded_data._current_elem = elem;
}

void
RaySystem::reinitNeighborFace(const Elem * elem,
                              unsigned long int /*side*/,
                              BoundaryID /*bnd_id*/,
                              THREAD_ID tid)
{
  std::cout << "Setting up neighbor info!" << std::endl;

  auto & threaded_data = _rs_threaded_data[tid];

  dof_id_type dof_number = elem->dof_number(number(), 0, 0);

  threaded_data._current_offset_neighbor =
      _current_group_solution.map_global_to_local_index(dof_number);

  auto & block_mats = _ray_materials_neighbor.getBlockObjects(elem->subdomain_id(), tid);

  if (block_mats.empty() || block_mats[0] == nullptr)
    mooseError("No RayMaterial on block ", elem->subdomain_id());

  _rs_threaded_data[tid]._current_ray_material_neighbor = block_mats[0];

  threaded_data._current_ray_material_neighbor->reinit(elem);

  threaded_data._current_elem_neighbor = elem;
}

void
RaySystem::sweep()
{
  VecGetArray(_current_group_solution.vec(), &_current_group_solution_values);
  for (unsigned long int tid = 0; tid < libMesh::n_threads(); tid++)
    VecGetArray(_rs_threaded_data[tid]._group_solution->vec(),
                &_rs_threaded_data[tid]._group_solution_values);

  _ray_problem.rayTracingStudy().executeStudy();

  // Close up all of the vectors
  VecRestoreArray(_current_group_solution.vec(), &_current_group_solution_values);
  _current_group_solution.close();

  for (unsigned long int tid = 0; tid < libMesh::n_threads(); tid++)
  {
    VecRestoreArray(_rs_threaded_data[tid]._group_solution->vec(),
                    &_rs_threaded_data[tid]._group_solution_values);

    _rs_threaded_data[tid]._group_solution->close();
  }
}

void
RaySystem::postSweep()
{
  _current_group_solution.zero();

  for (unsigned long int tid = 0; tid < libMesh::n_threads(); tid++)
    _current_group_solution += (*_rs_threaded_data[tid]._group_solution);

  _current_group_solution.close();

  // Before exiting... update this in case anyone wants it
  VecGetArray(_current_group_solution.vec(), &_current_group_solution_values);
}
